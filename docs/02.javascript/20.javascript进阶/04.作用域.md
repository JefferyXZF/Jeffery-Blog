---
title: 深入理解javascript作用域
date: 2020-01-20 14:27:01
permalink: /pages/wewweseadse
author: 
  name: jeffery
categories: 
  - javascript
tags: 
  - javascript
---

# 作用域、作用域链、执行上下文

## 作用域

作用域是指程序源代码中定义变量的区域。

作用域制定一套规则，用于确定在何处以及如何查找标识符（变量）


### 词法作用域和动态作用域

作用域分为词法作用域和动态作用域。`javascript` 使用的是词法作用域，

它们两者的区别，在词法作用域中函数的作用域在函数定义的时候就决定了；而动态作用域是在函数执行的时候才确定函数的作用域。

举例子，请看下面代码:
```js
var value = 1;

function foo() {
    console.log(value);
}

function bar() {
    var value = 2;
    foo();
}

bar();

// 结果是 ???
```

假设 `JavaScript` 采用词法作用域，让我们分析下执行过程：

执行 `foo` 函数，先从 `foo` 函数内部查找是否有局部变量 `value`，如果没有，就根据书写的位置，查找上面一层的代码，也就是 `value` 等于 1，所以结果会打印 1。

假设 `JavaScript` 采用动态作用域，让我们分析下执行过程：

执行 `foo` 函数，依然是从 `foo` 函数内部查找是否有局部变量 `value`。如果没有，就从调用函数的作用域，也就是 `bar` 函数内部查找 `value` 变量，所以结果会打印 2。

前面我们已经说了，`JavaScript` 采用的是静态作用域，所以这个例子的结果是 1。


## 执行上下文

`JavaScript` 在执行前会做“准备工作”，这个过程会创建“执行上下文”，执行上下文分为全局执行上下文、函数执行上下文、eval执行上下文。

当程序开始执行时，会创建一个全局执行上下文，如果遇到函数则创建函数执行上下文，每个执行函数都会创建一个不同的执行上下文，嵌套函数也不例外，那么这么多执行上下文是通过什么管理的呢？

答案是利用栈的数据结构，叫**执行上下文栈**

当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。直到执行完所有的函数，而全局执行上下文会在关闭浏览器标签或程序的时候才会被销毁


## 变量对象

上面说到，创建执行上下文，会同时创建三个重要属性：

- 变量对象(Variable object，VO)
- 作用域链(Scope chain)
- this

首先介绍变量对象。

变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。

变量对象包括：

1. 函数的所有形参 (如果是函数上下文)
   - 由名称和对应值组成的一个变量对象的属性被创建
   - 没有实参，属性值设为 undefined
2. 函数声明
   - 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
   - 如果变量对象已经存在相同名称的属性，则完全替换这个属性
3. 变量声明
   - 由名称和对应值（undefined）组成一个变量对象的属性被创建；
   - 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性



举个例子：

```js
function foo(a) {
  var b = 2;
  function c() {}
  var d = function() {};

  b = 3;

}

foo(1);
```

在进入执行上下文后，这时候的 AO 是：

```js
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: undefined,
    c: reference to function c(){},
    d: undefined
}
```



**代码执行**

在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值

还是上面的例子，当代码执行完后，这时候的 AO 是：

```
AO = {
    arguments: {
        0: 1,
        length: 1
    },
    a: 1,
    b: 3,
    c: reference to function c(){},
    d: reference to FunctionExpression "d"
}
```

到这里变量对象的创建过程就完了，总结上面的过程：

1. 全局上下文的变量对象初始化是全局对象
2. 函数上下文的变量对象初始化只包括 Arguments 对象
3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值
4. 在代码执行阶段，会再次修改变量对象的属性值





作用域分为全局作用域和函数作用域，函数作用域可以互相嵌套

在下面的例子中，存在着全局作用域，`fn` 作用域和 `bar` 作用域，它们相互嵌套

![scope2](https://gitee.com/FIF/pic-beg/raw/master/images/css/JS_ECMA_grammer_scope2.jpg)

**作用域链**

各个作用域的嵌套关系组成了一条作用域链。上面 `bar` 函数保存的作用域链是 `bar -> fn -> 全局`，`fn` 函数保存的作用域链是 `fn -> 全局`

使用作用域链主要是进行标识符的查询，标识符解析就是沿着作用域链一级一级地搜索标识符的过程，而作用域链就是要保证对变量和函数的有序访问

【1】如果自身作用域中声明了该变量，则无需使用作用域链

在下面的例子中，如果要在 `bar` 函数中查询变量 `a`，则赋值为100即可

```js
var a = 1;
function fn(x){
    var a = 10;
}
fn(0);
```

【2】如果自身作用域中未声明该变量，则需要使用作用域链进行查找

这时，就引出了另一个概念——**自由变量**。在当前作用域中存在但未在当前作用域中声明的变量叫自由变量

如果要在 `bar` 函数中查询变量 `b`，由于 `b` 并没有在当前作用域中声明，所以 `b` 是自由变量。`bar` 函数的作用域链是 `bar -> fn -> 全局`。到上一级 `fn` 作用域中查找 `b` 没有找到，继续到再上一级全局作用域中查找`b`，找到了 `b`

```js
var a = 1;
var b = 2;
function fn(x){
    var a = 10;
    function bar(x){
        var a = 100;
        b = x + a;
        return b;
    }
    bar(20);
    bar(200);
}
fn(0);
```

如果标识符没有找到，则需要分为 `RHS` 和 `LHS` 查询进行分析，若进行的是 `LHS` 查询，则在全局环境中声明该变量，若是严格模式下的 `LHS` 查询，则抛出 `ReferenceError` (引用错误)异常；若进行的是 `RHS` 查询，则抛出ReferenceError(引用错误)异常